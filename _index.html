<!DOCTYPE html>
<html lang="uk">
<head>
  <meta charset="UTF-8">
  <title>Віртуальне місто для учнів</title>
  <style>
    html, body { height: 100%; margin: 0; overflow: hidden; }
    body { background: #111; }
    #help {
      position: absolute;
      left: 16px; top: 16px;
      padding: 12px 20px;
      background: rgba(30,30,30,0.7);
      color: #fff;
      border-radius: 10px;
      font-family: Arial,sans-serif;
      z-index: 10;
      user-select: none;
    }
  </style>
</head>
<body>
  <div id="help">
    <b>WASD</b> — рухатися <br>
    <b>Миша</b> — крутити огляд <br>
    <b>Клік</b> — зайти в режим ходьби<br>
    <b>ESC</b> — вийти
  </div>
  <script src="https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.152.2/examples/js/controls/PointerLockControls.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.152.2/examples/js/loaders/GLTFLoader.js"></script>

  <script>
    let camera, scene, renderer, controls;
    let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false;
    let canJump = false, velocity = new THREE.Vector3(), direction = new THREE.Vector3();
    let prevTime = performance.now();

    init();
    animate();

    function init() {
      camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
      camera.position.set(0, 2, 8);

      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x22232a);

      // LIGHT
      scene.add(new THREE.HemisphereLight(0xffffff, 0x444444, 1));
      let light = new THREE.DirectionalLight(0xffffff, 0.5);
      light.position.set(10, 20, 0);
      scene.add(light);

      // RENDERER
      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);

      // CONTROLS
      controls = new THREE.PointerLockControls(camera, document.body);

      document.addEventListener('click', () => controls.lock(), false);
      controls.addEventListener('lock', () => document.getElementById('help').style.display = 'none');
      controls.addEventListener('unlock', () => document.getElementById('help').style.display = '');

      // LOAD GLB
      let loader = new THREE.GLTFLoader();
      loader.load('city/source/city.glb', function(gltf) {
        let city = gltf.scene;
        city.traverse(child => {
          if (child.isMesh) child.castShadow = child.receiveShadow = true;
        });
        scene.add(city);
      }, undefined, function(e){alert('Помилка завантаження моделі!');});

      // FLOOR (щоб не провалювались)
      let floor = new THREE.Mesh(
        new THREE.PlaneGeometry(200, 200),
        new THREE.MeshPhongMaterial({ color: 0x6a8a7b, depthWrite: false })
      );
      floor.rotation.x = -Math.PI / 2;
      floor.position.y = 0;
      floor.receiveShadow = true;
      scene.add(floor);

      // Клавіші
      const onKeyDown = function (e) {
        switch (e.code) {
          case 'ArrowUp': case 'KeyW': moveForward = true; break;
          case 'ArrowLeft': case 'KeyA': moveLeft = true; break;
          case 'ArrowDown': case 'KeyS': moveBackward = true; break;
          case 'ArrowRight': case 'KeyD': moveRight = true; break;
          case 'Space': if (canJump) { velocity.y += 5; canJump = false; } break;
        }
      };
      const onKeyUp = function (e) {
        switch (e.code) {
          case 'ArrowUp': case 'KeyW': moveForward = false; break;
          case 'ArrowLeft': case 'KeyA': moveLeft = false; break;
          case 'ArrowDown': case 'KeyS': moveBackward = false; break;
          case 'ArrowRight': case 'KeyD': moveRight = false; break;
        }
      };
      document.addEventListener('keydown', onKeyDown);
      document.addEventListener('keyup', onKeyUp);

      window.addEventListener('resize', onWindowResize);
    }

    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function animate() {
      requestAnimationFrame(animate);

      if (controls.isLocked === true) {
        let time = performance.now();
        let delta = (time - prevTime) / 1000;

        velocity.x -= velocity.x * 10.0 * delta;
        velocity.z -= velocity.z * 10.0 * delta;
        velocity.y -= 9.8 * 5.0 * delta; // gravity

        direction.z = Number(moveForward) - Number(moveBackward);
        direction.x = Number(moveRight) - Number(moveLeft);
        direction.normalize();

        if (moveForward || moveBackward) velocity.z -= direction.z * 50.0 * delta;
        if (moveLeft || moveRight) velocity.x -= direction.x * 50.0 * delta;

        controls.moveRight(-velocity.x * delta);
        controls.moveForward(-velocity.z * delta);

        camera.position.y += velocity.y * delta;
        if (camera.position.y < 2) {
          velocity.y = 0;
          camera.position.y = 2;
          canJump = true;
        }

        prevTime = time;
      }

      renderer.render(scene, camera);
    }
  </script>
</body>
</html>

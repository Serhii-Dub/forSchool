<!DOCTYPE html>
<html lang="uk">
<head>
  <meta charset="UTF-8">
  <title>AR –†–æ–±–æ—Ç –∑ –∂–µ—Å—Ç–∞–º–∏</title>
  <style>
    html, body { margin:0; padding:0; overflow:hidden; background:#222;}
    #info {
      position: absolute; top: 10px; left: 0; right: 0; z-index: 10;
      color: #fff; font-family: Segoe UI,Arial,sans-serif; text-align: center;
      text-shadow: 0 1px 8px #000c;
      font-size: 1.15em;
    }
    #video {
      position: fixed; top:0; left:0; width:120px; height:90px; z-index:5; opacity:0.3; pointer-events:none;
    }
  </style>
</head>
<body>
  <div id="info">
    <b>AR –†–æ–±–æ—Ç ‚Äì –∫–µ—Ä—É–≤–∞–Ω–Ω—è –∂–µ—Å—Ç–∞–º–∏:</b><br>
    ‚úã –≤—ñ–¥–∫—Ä–∏—Ç–∞ –¥–æ–ª–æ–Ω—è ‚Äî —Å—Ç–æ—ó—Ç—å<br>
    üëä –∫—É–ª–∞–∫ ‚Äî –∑–º—ñ–Ω–∞ –∫–æ–ª—å–æ—Ä—É<br>
    (–†–æ–∑–ø—ñ–∑–Ω–∞–Ω–Ω—è –∂–µ—Å—Ç—ñ–≤ —á–µ—Ä–µ–∑ –∫–∞–º–µ—Ä—É)
  </div>
  <video id="video" autoplay playsinline></video>
  <canvas id="canvas3d"></canvas>
  <script type="module">
    import * as THREE from 'https://unpkg.com/three@0.161.0/build/three.module.js';

    // === MediaPipe Hands ===
    import { HandLandmarker, FilesetResolver } from "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision/vision_bundle.mjs";

    let handLandmarker, video, robot, robotColor = 0x1ec8e7, isFist = false;
    let scene, camera, renderer;

    async function initHandTracking() {
      handLandmarker = await HandLandmarker.createFromOptions(
        await FilesetResolver.forVisionTasks('https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@latest/wasm'),
        {numHands: 1, runningMode: "VIDEO"}
      );

      video = document.getElementById("video");
      navigator.mediaDevices.getUserMedia({ video: { facingMode: "user" } })
        .then((stream) => {
          video.srcObject = stream;
          video.play();
          requestAnimationFrame(trackHands);
        });
    }

    function isOpenPalm(landmarks) {
      // –í—ñ–¥—Å—Ç–∞–Ω—å –≤—ñ–¥ –∑–∞–ø‚Äô—è—Å—Ç—è –¥–æ –∫—ñ–Ω—á–∏–∫–∞ —Å–µ—Ä–µ–¥–Ω—å–æ–≥–æ –ø–∞–ª—å—Ü—è –±—ñ–ª—å—à–∞ –Ω—ñ–∂ —É –∫—É–ª–∞–∫–∞
      if (!landmarks) return false;
      const wrist = landmarks[0], mid = landmarks[12];
      const dist = Math.hypot(mid.x - wrist.x, mid.y - wrist.y);
      // –ø–∞–ª—å—Ü—ñ –ø—Ä—è–º—ñ ‚Äî –∫—ñ–Ω—á–∏–∫ —Å–µ—Ä–µ–¥–Ω—å–æ–≥–æ –¥–∞–ª–µ–∫–æ –≤—ñ–¥ –∑–∞–ø'—è—Å—Ç—è
      return dist > 0.25 && isAllFingersOpen(landmarks);
    }

    function isFistGesture(landmarks) {
      // –í—Å—ñ –∫—ñ–Ω—á–∏–∫–∏ –ø–∞–ª—å—Ü—ñ–≤ –±–ª–∏–∑—å–∫–æ –¥–æ –∑–∞–ø‚Äô—è—Å—Ç—è
      if (!landmarks) return false;
      let closed = 0;
      [8,12,16,20].forEach(i => {
        const tip = landmarks[i], wrist = landmarks[0];
        if (Math.hypot(tip.x-wrist.x, tip.y-wrist.y)<0.12) closed++;
      });
      return closed >= 3;
    }
    function isAllFingersOpen(landmarks) {
      // –ü–µ—Ä–µ–≤—ñ—Ä–∏—Ç–∏ —á–∏ –≤—Å—ñ –ø–∞–ª—å—Ü—ñ –≤—ñ–¥–∫—Ä–∏—Ç—ñ
      if (!landmarks) return false;
      let open = 0;
      [8,12,16,20].forEach(i => {
        const tip = landmarks[i], pip = landmarks[i-2];
        if (tip.y < pip.y) open++;
      });
      return open >= 3;
    }

    async function trackHands() {
      if (!video || video.readyState !== 4) {
        requestAnimationFrame(trackHands);
        return;
      }
      const results = handLandmarker.detectForVideo(video, performance.now());
      let gesture = "none";
      if (results.landmarks && results.landmarks.length > 0) {
        const lm = results.landmarks[0];
        if (isFistGesture(lm)) gesture = "fist";
        else if (isOpenPalm(lm)) gesture = "palm";
      }

      // === –†–µ–∞–∫—Ü—ñ—è –Ω–∞ –∂–µ—Å—Ç–∏ ===
      if (gesture === "palm") {
        robot.userData.state = "stand";
      } else if (gesture === "fist" && !isFist) {
        robotColor = Math.random()*0xffffff;
        robot.traverse(child=>{if(child.isMesh) child.material.color.setHex(robotColor)});
        isFist = true;
      } else if (gesture !== "fist") {
        isFist = false;
      }
      requestAnimationFrame(trackHands);
    }

    // === THREE.js —Å—Ü–µ–Ω–∞ ===
    function initThree() {
      scene = new THREE.Scene();
      camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.01, 100);
      camera.position.set(0,0.25,1.1);

      renderer = new THREE.WebGLRenderer({canvas:document.getElementById("canvas3d"), alpha:true, antialias:true});
      renderer.setSize(window.innerWidth, window.innerHeight);

      // –†–æ–±–æ—Ç
      robot = new THREE.Group();
      let mat = new THREE.MeshPhongMaterial({color:robotColor});
      let body = new THREE.Mesh(new THREE.BoxGeometry(0.22,0.33,0.1), mat.clone());
      body.position.y = 0.17; robot.add(body);
      let head = new THREE.Mesh(new THREE.BoxGeometry(0.13,0.13,0.13), mat.clone());
      head.position.y = 0.34; robot.add(head);
      let leg1 = new THREE.Mesh(new THREE.BoxGeometry(0.06,0.18,0.06), mat.clone());
      leg1.position.set(-0.06,0.04,0); robot.add(leg1);
      let leg2 = leg1.clone(); leg2.position.set(0.06,0.04,0); robot.add(leg2);
      let arm1 = new THREE.Mesh(new THREE.BoxGeometry(0.05,0.16,0.05), mat.clone());
      arm1.position.set(-0.15,0.23,0); robot.add(arm1);
      let arm2 = arm1.clone(); arm2.position.set(0.15,0.23,0); robot.add(arm2);
      robot.position.set(0,0,-0.7);
      robot.userData.state = "stand";
      scene.add(robot);

      const light = new THREE.HemisphereLight(0xffffff, 0x444444, 1.2);
      light.position.set(0,1,0); scene.add(light);

      window.addEventListener("resize", ()=>{
        renderer.setSize(window.innerWidth, window.innerHeight);
        camera.aspect = window.innerWidth/window.innerHeight;
        camera.updateProjectionMatrix();
      });
    }

    function animate() {
      renderer.setAnimationLoop(()=>{
        // –ê–Ω—ñ–º–∞—Ü—ñ—è (–Ω–∞–ø—Ä–∏–∫–ª–∞–¥, –º–æ–∂–Ω–∞ —Ä—É—Ö–∞—Ç–∏ –Ω–æ–≥–∏, —è–∫—â–æ state ‚â† "stand")
        renderer.render(scene, camera);
      });
    }

    // === RUN ===
    initThree();
    initHandTracking();
    animate();
  </script>
</body>
</html>

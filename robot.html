<!DOCTYPE html>
<html lang="uk">
<head>
  <meta charset="UTF-8">
  <title>–ñ–µ—Å—Ç–∏ –¥–ª—è –∫–µ—Ä—É–≤–∞–Ω–Ω—è —Ä–æ–±–æ—Ç–æ–º</title>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>
  <script src="https://unpkg.com/three@0.161.0/build/three.min.js"></script>
  <style>
    body { margin:0; overflow:hidden; background: #222;}
    #canvas3d { position:fixed; top:0; left:0; width:100vw; height:100vh; }
    #info {
      position: absolute; top: 10px; left: 0; right: 0; z-index: 10;
      color: #fff; font-family: Segoe UI,Arial,sans-serif; text-align: center;
      text-shadow: 0 1px 8px #000c; font-size: 1.08em;
      background: rgba(0,0,0,0.4); padding: 5px 0;
    }
    #video {
      position:fixed; right:0; bottom:0; width:200px; opacity:0.13; z-index:3;
      border-radius:18px;
      pointer-events:none;
    }
  </style>
</head>
<body>
  <div id="info">
    üëã <b>–†—É—Ö–∞–π —Ä—É–∫–æ—é –≤ –∫–∞–º–µ—Ä—É!</b><br>
    <b>–í–∫–∞–∑—ñ–≤–Ω–∏–π –ø–∞–ª–µ—Ü—å ‚Üí –í–ª—ñ–≤–æ/–í–ø—Ä–∞–≤–æ/–í–≥–æ—Ä—É/–í–Ω–∏–∑ = –∫—Ä–æ–∫–∏ —Ä–æ–±–æ—Ç–∞</b><br>
    <b>–í—ñ–¥–∫—Ä–∏—Ç–∞ –¥–æ–ª–æ–Ω—è = —Å—Ç–æ—ó—Ç—å</b> | <b>–ö—É–ª–∞–∫ = –∑–º—ñ–Ω–∞ –∫–æ–ª—å–æ—Ä—É</b>
  </div>
  <video id="video" playsinline></video>
  <canvas id="canvas3d"></canvas>
  <script>
    // Three.js basic scene
    let scene = new THREE.Scene();
    let camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.01, 100);
    camera.position.set(0,0.25,1.1);
    let renderer = new THREE.WebGLRenderer({canvas: document.getElementById('canvas3d'), alpha:true, antialias:true});
    renderer.setSize(window.innerWidth, window.innerHeight);

    // Simple robot
    let robot = new THREE.Group();
    let robotColor = 0x1ec8e7;
    let mat = new THREE.MeshPhongMaterial({color:robotColor});
    let body = new THREE.Mesh(new THREE.BoxGeometry(0.22,0.3,0.1), mat.clone());
    body.position.y = 0.13; robot.add(body);
    let head = new THREE.Mesh(new THREE.BoxGeometry(0.13,0.13,0.12), mat.clone());
    head.position.y = 0.31; robot.add(head);
    let leg1 = new THREE.Mesh(new THREE.BoxGeometry(0.06,0.14,0.07), mat.clone());
    leg1.position.set(-0.06,0.02,0); robot.add(leg1);
    let leg2 = leg1.clone(); leg2.position.x = 0.06; robot.add(leg2);
    let arm1 = new THREE.Mesh(new THREE.BoxGeometry(0.05,0.13,0.07), mat.clone());
    arm1.position.set(-0.15,0.20,0); robot.add(arm1);
    let arm2 = arm1.clone(); arm2.position.x = 0.15; robot.add(arm2);

    robot.position.set(0,0,0);
    scene.add(robot);

    let light = new THREE.HemisphereLight(0xffffff, 0x222233, 1.7);
    scene.add(light);

    // Gesture logic
    function setRobotColor(newColor) {
      robot.traverse(c=>{
        if (c.isMesh) c.material.color.setHex(newColor);
      });
    }

    // MediaPipe hands
    const videoElement = document.getElementById('video');
    let cameraM;
    let lastGesture = "stop";
    let lastColorChange = Date.now();

    function getGesture(landmarks) {
      // very basic: check finger states
      if (!landmarks) return "stop";
      let tip = (i) => landmarks[i];
      let isUp = idx => tip(idx).y < tip(idx-2).y;
      // open palm: all fingers up
      let fingers = [8,12,16,20].map(i=> isUp(i));
      if (fingers.every(x=>x)) return "stop";
      // index only: direction
      if (isUp(8)&& !isUp(12)&&!isUp(16)&&!isUp(20)) {
        let dx = tip(8).x - tip(5).x;
        let dy = tip(8).y - tip(5).y;
        if (Math.abs(dx) > Math.abs(dy)) {
          if (dx < -0.07) return "left";
          if (dx > 0.07) return "right";
        } else {
          if (dy < -0.07) return "up";
          if (dy > 0.07) return "down";
        }
      }
      // fist (all down): color
      if ([8,12,16,20].every(i=>!isUp(i))) return "color";
      return "stop";
    }

    function onResults(results) {
      if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
        let gesture = getGesture(results.multiHandLandmarks[0]);
        if (gesture !== lastGesture) {
          if (gesture==="left")    robot.position.x -= 0.09;
          if (gesture==="right")   robot.position.x += 0.09;
          if (gesture==="up")      robot.position.z -= 0.11;
          if (gesture==="down")    robot.position.z += 0.11;
          if (gesture==="color" && Date.now()-lastColorChange > 800) {
            robotColor = Math.random()*0xffffff;
            setRobotColor(robotColor|0);
            lastColorChange = Date.now();
          }
          lastGesture = gesture;
        }
      } else {
        lastGesture = "stop";
      }
    }

    // MediaPipe setup
    const hands = new Hands({
      locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
    });
    hands.setOptions({
      maxNumHands: 1,
      modelComplexity: 0,
      minDetectionConfidence: 0.7,
      minTrackingConfidence: 0.6
    });
    hands.onResults(onResults);

    cameraM = new Camera(videoElement, {
      onFrame: async () => { await hands.send({image: videoElement}); },
      width: 480, height: 360
    });
    cameraM.start();

    // Render loop
    function animate() {
      renderer.render(scene, camera);
      requestAnimationFrame(animate);
    }
    animate();

    window.addEventListener('resize', ()=>{
      renderer.setSize(window.innerWidth, window.innerHeight);
      camera.aspect = window.innerWidth/window.innerHeight;
      camera.updateProjectionMatrix();
    });
  </script>
</body>
</html>
